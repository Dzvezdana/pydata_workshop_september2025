# Multi-Agent Event-Driven Workflows

## Assignment 3. Workflow Orchestrators

A crucial component of multi-agent systems is the orchestrator that coordinates interactions between agents. Dapr Agents supports three orchestration strategies: Random, LLM-based and RoundRobin.

### Random Orchestrator

The Random orchestrator selects agents randomly to respond to queries. Open the `services/workflow-random/app.py` file in the Editor window to see how it is implemented.

```python
from dapr_agents import RandomOrchestrator
from dotenv import load_dotenv
import asyncio
import logging

async def main():
    try:
        random_workflow_service = RandomOrchestrator(
            name="RandomOrchestrator",
            message_bus_name="messagepubsub",
            state_store_name="agenticworkflowstate",
            state_key="workflow_state",
            agents_registry_store_name="agentstatestore",
            agents_registry_key="agents_registry",
            max_iterations=3
        ).as_service(port=8004)
        await random_workflow_service.start()
    except Exception as e:
        print(f"Error starting service: {e}")
```

This approach is useful for:

* Load balancing across agents
* Creating more diverse conversations
* Testing and debugging multi-agent interactions

### RoundRobin Orchestrator

The RoundRobin orchestrator cycles through agents in a predetermined sequence.

This approach ensures:

* Equal participation from all agents
* Predictable turn-taking behavior
* Fair distribution of tasks

### LLM-Based Orchestrator

The LLM-based orchestrator uses an LLM to intelligently select the most appropriate agent for each query. 

This approach provides:

* Context-aware agent selection
* Dynamic adaptation to conversation flow
* More natural multi-agent interactions

## Running the Multi-Agent System

So far we started our agent application few times using the Dapr CLI command `dapr run -f dapr-random.yaml`.

The Dapr CLI provides a multi-app run feature that allows you to start multiple applications with their Dapr sidecars using a single command. This is essential for running multi-agent systems where several services need to work together.

Examine the `dapr-random.yaml` configuration file:

```yaml
version: 1
common:
  resourcesPath: ./components
  logLevel: info
  appLogDestination: console
  daprdLogDestination: console

apps:
- appID: HobbitApp
  appDirPath: ./services/hobbit/
  command: ["python3", "app.py"]

- appID: WizardApp
  appDirPath: ./services/wizard/
  command: ["python3", "app.py"]

- appID: ElfApp
  appDirPath: ./services/elf/
  command: ["python3", "app.py"]

- appID: WorkflowApp
  appDirPath: ./services/workflow-random/
  command: ["python3", "app.py"]
  appPort: 8004

- appID: ClientApp
  appDirPath: ./services/client/
  command: ["python3", "http_client.py"]
```

## How Multi-Agent Collaboration Works

Let's tie it all together and explore how the collaboration works in a typical multi-agent interaction:

Client Submits a Query: "How to get to Mordor? We all need to help!"
Orchestrator Receives the Query: The orchestrator (Random, RoundRobin, or LLM-based) receives the query
Agent Selection: The orchestrator selects an agent to respond (based on its strategy)
Agent Processes the Query: The selected agent generates a response
Response Publication: The agent publishes its response to the pub/sub system
Orchestrator Evaluates: The orchestrator decides if more agent input is needed
Additional Agent Selection: If needed, another agent is selected to contribute
Response Aggregation: The contributions are collected into a coherent conversation
Client Receives Response: The final response is sent back to the client

This cycle can continue for multiple iterations until the task is complete or a maximum number of iterations is reached.

## Exercise 1: Implement Different Coordination Strategies - LLM-Based

Let's implement an LLM orchestrator.

1. Implement `workflow-llm` in `services`.
2. Implement `dapr-llm.yaml`.

Then run the application using:

```
dapr run -f dapr-llm.yaml
```

For more information, take a look at the docs: https://v1-16.docs.dapr.io/developing-applications/dapr-agents/dapr-agents-core-concepts/#event-driven-orchestration

**Expected output:** The agents will engage in a conversation about getting to Mordor, with different agents contributing based on their character. Observe that in the logs.

### Exercise 1 (a): Inspect the output of the LLM-based orchestator

The LLM-based orchestrator has saved the output in a file named LLMOrchestrator_state.json located in the services/workflow-llm/ folder.

[!Note] Since this json file is generated by the orchestrator, it will not be visible in the Editor window tree view until you have refreshed the tree view using the circular arrow icon.

Use the Editor window to open the services/workflow-llm/LLMOrchestrator_state.json file and inspect its content. The file contains an instances element with different instance ID values, each containing input and output values, messages, and a plan with steps and sub steps with a status.

[!Note] The LLM-based orchestrator makes many calls to HuggingFace API and could result in rate limiting your access to the HuggingFace API.

## Exercise 2: Implement Different Coordination Strategies - RoundRobin

Let's implement RoundRobin orchestrator.

1. Implement `workflow-roundrobin` in `services`.
2. Implement `dapr-roundrobin.yaml`.

Then run the application using:

```
dapr run -f dapr-roundrobin.yaml 
```

The RoundRobin orchestrator cycles through agents in a predetermined sequence.

**Expected output:** The agents will engage in a conversation about getting to Mordor, with different agents contributing based on their character. Observe that in the logs.

## Troubleshooting

1. **Service Startup**: If services fail to start, verify Dapr components configuration
2. **Communication Issues**: Check Redis connection and pub/sub setup
3. **Workflow Errors**: Check Zipkin traces for detailed request flows
4. **Port Conflicts**: If ports are already in use, check which port is already in use
5. **System Reset**: Clear Redis data through Redis Insights if needed
